# API

The built-in REST API makes it easy to query your indexed data programmatically.

## Base URL

The API runs on `http://localhost:9720` by default.

## Endpoints Overview

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/list_events` | GET | List all indexed event types |
| `/list_contracts` | GET | List all indexed contracts |
| `/db_schema` | GET | Get database schema |
| `/raw_query` | POST | Execute a raw SQL query |



## 1. List Events

Returns all event descriptors indexed in the database along with their indexing status.

**Endpoint:** `GET /list_events`

**Example:**

```bash
curl http://localhost:9720/list_events
```

**Response:**

```json
{
  "events": [
    {
      "chainId": 1,
      "eventHash": "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
      "eventSignature": "Transfer(address,address,uint256)",
      "eventName": "Transfer",
      "firstBlock": 23744000,
      "lastBlock": 23780000,
      "eventCount": 15420
    }
  ]
}
```

**Response Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `chainId` | number | Chain ID of the indexed blockchain |
| `eventHash` | string | Keccak256 hash of the event signature |
| `eventSignature` | string | Full event signature |
| `eventName` | string | Event name (e.g., "Transfer") |
| `firstBlock` | number | First indexed block for this event |
| `lastBlock` | number | Last indexed block for this event |
| `eventCount` | number | Total number of indexed events |



## 2. List Contracts

Returns all contracts that have been indexed.

**Endpoint:** `GET /list_contracts`

**Example:**

```bash
curl http://localhost:9720/list_contracts
```

**Response:**

```json
{
  "contracts": [
    {
      "contract_address": "0x57f1887a8BF19b14fC0dF6Fd9B2acc9Af147eA85"
    }
  ]
}
```

**Response Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `contract_address` | string | Contract address (hex with 0x prefix) |



## 3. Database Schema

Returns the database schema including all tables and their column definitions.

**Endpoint:** `GET /db_schema`

**Example:**

```bash
curl http://localhost:9720/db_schema
```

**Response:**

```json
{
  "schema": [
    {
      "blocks_1": {
        "block_hash": "VARCHAR",
        "block_number": "UBIGINT",
        "block_timestamp": "UBIGINT"
      }
    },
    {
      "event_1_transfer_ddf25": {
        "block_number": "UBIGINT",
        "contract_address": "VARCHAR",
        "from": "VARCHAR",
        "log_index": "USMALLINT",
        "to": "VARCHAR",
        "tokenId": "BIGNUM",
        "transaction_hash": "VARCHAR"
      }
    },
    {
      "event_descriptor": {
        "chain_id": "UBIGINT",
        "event_hash": "VARCHAR",
        "event_name": "VARCHAR",
        "event_signature": "VARCHAR",
        "first_block": "UBIGINT",
        "last_block": "UBIGINT"
      }
    }
  ]
}
```

This endpoint is useful for discovering the structure of event tables dynamically.

**Table Naming Conventions:**

- `blocks_<chain_id>` â€” Block data per chain (e.g., `blocks_1` for Ethereum mainnet)
- `event_<chain_id>_<event_name>_<hash_prefix>` â€” Event data (e.g., `event_1_transfer_ddf25`)
- `event_descriptor` â€” Registry of all indexed event types

> ðŸ’¡ The `hash_prefix` is the first 5 hex characters of the event's keccak256 hash â€” for example, `ddf25` comes from `0xddf252ad...`



## 4. Raw Query

Execute a raw SQL SELECT query against the database.

**Endpoint:** `POST /raw_query`

**Request Body:**

```json
{
  "query": "SELECT * FROM blocks LIMIT 10"
}
```

**Parameters:**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `query` | string | Yes | SQL SELECT query to execute |

> âš ï¸ **Note:** Only `SELECT` queries are supported. Other SQL operations (INSERT, UPDATE, DELETE, etc.) will be rejected.

### Examples

#### Query blocks table

```bash
curl -X POST http://localhost:9720/raw_query \
  -H "Content-Type: application/json" \
  -d '{"query": "SELECT * FROM blocks_1 ORDER BY block_number DESC LIMIT 5"}'
```

#### Count events

```bash
curl -X POST http://localhost:9720/raw_query \
  -H "Content-Type: application/json" \
  -d '{"query": "SELECT COUNT(*) as total FROM event_1_transfer_ddf25"}'
```

#### Query with filtering

```bash
curl -X POST http://localhost:9720/raw_query \
  -H "Content-Type: application/json" \
  -d '{
    "query": "SELECT block_number, block_timestamp FROM blocks_1 WHERE block_number > 23780000 ORDER BY block_number DESC LIMIT 5"
  }'
```

#### Get top receivers (Transfer events)

```bash
curl -X POST http://localhost:9720/raw_query \
  -H "Content-Type: application/json" \
  -d '{
    "query": "SELECT \"to\", COUNT(*) as transfer_count FROM event_1_transfer_ddf25 GROUP BY \"to\" ORDER BY transfer_count DESC LIMIT 10"
  }'
```

**Response:**

```json
{
  "query_result": [
    {
      "block_number": 23783860,
      "block_hash": "0x...",
      "block_timestamp": 1731420743
    }
  ]
}
```



## Error Responses

All endpoints return errors in the following format:

```json
{
  "error": "Error message description"
}
```

**HTTP Status Codes:**

| Code | Description |
|------|-------------|
| `200 OK` | Success |
| `400 Bad Request` | Invalid request (e.g., non-SELECT query) |
| `500 Internal Server Error` | Server error (e.g., database connection issue) |

**Example error (non-SELECT query):**

```bash
curl -X POST http://localhost:9720/raw_query \
  -H "Content-Type: application/json" \
  -d '{"query": "DELETE FROM blocks"}'
```

Response:
```json
{
  "error": "Only SELECT queries are supported."
}
```



## Pretty-printing Responses

Use `jq` for formatted output:

```bash
curl http://localhost:9720/list_events | jq '.'
```

Or Python:

```bash
curl http://localhost:9720/list_events | python3 -m json.tool
```



## Notes

- GET endpoints don't require a request body
- POST endpoints expect `Content-Type: application/json`
- Table names include chain ID (e.g., `blocks_1` for chain 1)
- Event tables follow the pattern `event_<chain_id>_<event_name>_<hash_prefix>`
- Use `/db_schema` to discover available tables and their columns
- Reserved SQL keywords used as column names (like `from`, `to`) need quoting in queries
